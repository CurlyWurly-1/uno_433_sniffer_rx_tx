/*
sketch : sniffer_433_RX       (sister of "sniffer_433_TX")
Author : Peter Matthews (CurlyWurly)   May 2017
Desc   : When a static 433 transmission is received, a "int codez[]=.." line is output to the serial bus.
         Copy this line and paste it into the the sister sketch "sniffer_433_TX"   
INFORMATION
  N.B. BE AWARE THAT IF ONLY A SINGLE MESSAGE IS SENT, THIS VERSION WILL NOT SEE IT !!!
       THIS VERSION WAITS FOR A LONG ENOUGH LOW PULSE BEFORE TRIGGERING ON THE NEXT "HIGH" 
       i.e. THIS SKETCH RELIES ON A MESSAGE BEING REPEATED WITH THE 2ND (repeated) MESSAGE BEING DECIPHERED!!!!!!
       THE IDEA IS THAT YOU TRIGGER THE TRANSMITTER CLOSE TO THE INPUT AERIAL AND ITS STRONG SIGNAL ENSURES THAT A
       NICE CLEAN SIGNAL IS ANALYSED BECAUSE THE "AGC" OF THE RECEIVER WILL HAVE THROTTLED DOWN BY THE TIME THE 
       2nd MESSAGE IS SEEN (this ensures that any interupting far away signals are nicely filtered out) 
  N.B. Connect pin 2 (rxpin) to the RX module output
  N.B. Copy the output "int codez[] = ...." from serial bus and copy into the sister sketch "Sniffer_433_TX"
  N.B. This sniffer sketch just outputs a set value of 35 in code[0]. This means that you may have to 
       experiment using a different "repeat" value (usually a value of 15 - 45) when used in the "TX" sketch 
  N.B. The code structure is contained from code[0] to code[n] and is defined as:
          code[0] - No. of times to repeat the code
          code[1] - No. of pulses (Hi/low combination) - This means it is half the total number of Hi and Low states 
          code[2] - Wait unit time (Hi and Low states are constructed with multiples of this) 
          code[3] - First HIGH state multiplier - multiply with code[2]   
          code[4] - First LOW  state multiplier - multiply with code[2]   
          ....
          code[n] - last LOW   state multiplier
      The     first  pulse is made up of code[3] and code[4]
      and the second pulse is made up of code[5] and code[6]
*/

#define rxPin            2    // Input from receiver
#define minStates       24    // Min States (used to calculate a low pulse) 
#define lowMultiplier  1.1    // Min States (used to calculate a low pulse) 
#define maxState       300    // Maximum States (Halve for pulses, will detect "pulse trains" up to 150 pulses long)
#define minBreakLow   2000    // Min break pause   
#define maxSmooth        3    // Smoothing factor 
 
bool          trig;               // recording started
bool          pinstate;           // State of input pin - Hi(1) or Low(0)
bool          newPin;             // Smoothed pin state
int           stateCount;         // State change counter
int           pulses;             // Number of pulses (half of stateCount) 
int           i;                  // Array counter
int           cnt;                // 


unsigned long T_array[maxState];  // Array of HiLo pulse lengths (starts with Hi)
bool          B_array[(maxState/2)];  // Array of bits translated from the HiLo pulse lengths 
unsigned long firstLow;           // First Low length (can replace lastLow)
unsigned long longestLowPulse;    // Longest  LOW pulse length in us
unsigned long shortestHiPulse;    // Shortest HI  pulse length in us
unsigned long pulseLen;           // pulse length in us
unsigned long startTime;          // Start Time of pulse in us
unsigned long endTime;            // End   Time of pulse in us
unsigned long unitlen;            // lowest AVG pulse length in us (assumed L.C.Denominator)

void data_output();


//*********************************************************************************************
void setup() {
//*********************************************************************************************
  pinMode(rxPin, INPUT);      // initialize input pin used for input signal
//  Serial.begin(115200);       // Set up Serial baud rate 
  Serial.begin(2000000);       // Set up Serial baud rate 
  Serial.println("Scanning for 433Mhz signals (selects 2nd repeated message)");
  startTime     = micros();   // Store first "Start time"
  pinstate      = false;      // prepare stored version of pin state to start as "low"
  trig          = false;      // initialise 
  stateCount        = 0;           // initialise 
  longestLowPulse   = 0;
  cnt = 0;
}

//*********************************************************************************************
void loop() {
//*********************************************************************************************

   if ( stateCount > minStates  && ( pinstate == false ) )
   { if ( ( ( micros()-startTime ) > ( longestLowPulse * lowMultiplier ) ) && ( trig == true ) ) 
      {
        data_output();
        trig              = false;       // initialise 
        stateCount        = 0;           // initialise 
        longestLowPulse   = 0;
        shortestHiPulse   = 999999;
      };
   };

// Smooth pinstate
  if ( digitalRead(rxPin) == true)
  {
    if ( newPin == true )
    {
       cnt = maxSmooth;
    }else
    {
      cnt = cnt + 1; 
      if ( cnt >= maxSmooth )
      {
        cnt = maxSmooth;
        newPin = true;  
      };
    };
  }else{
    if ( newPin == false )
    {
       cnt = 0;
    }else
    {
      cnt = cnt - 1; 
      if ( cnt <= 0 )
      {
        cnt = 0;
        newPin = false;  
      };
    };
  }; 


// If a state change, then calculate pulselen
//  if (pinstate != digitalRead(rxPin)) {
  if ( pinstate != newPin ) {
    pinstate   = !pinstate;
    endTime    = micros();                // Record the end time of the read period.
    pulseLen   = endTime - startTime;     // Calculate Pulse length in us
    startTime  = endTime;                 // Remember start time for next state change

// If  previous pulse Length is less than 100 Us or greater than 50ms, reset 
    if ( ( pulseLen < 300 ) || ( pulseLen > 100000 ) ) {
      trig          = false; 
    } else {
      if ( ( trig == false ) &&  ( pulseLen > minBreakLow)  &&  ( pinstate == true ) ) {
        trig              = true;       // initialise 
        stateCount        = 0;          // initialise 
        firstLow          = pulseLen;
        longestLowPulse   = 0;
        shortestHiPulse   = 999999;
        return;  
      };
    };

// Return if not triggered 
    if ( trig == false ) { 
      return;      
    };


// Store previous state time length (N.B. even indexes are for high, odd index is for low)
    T_array[stateCount] = pulseLen;            // Store Pulse Length 

    if ( stateCount < minStates  )
    {
      if ( pinstate == true ) 
      {
        if ( pulseLen > longestLowPulse )
        {
          longestLowPulse = pulseLen;          
        };
      }else{
        if ( pulseLen < shortestHiPulse )
        {
          shortestHiPulse = pulseLen;          
        };
      }
      if ( pulseLen < 50000 ) 
      {
        stateCount++;    
        return;      
      };
    }else{
      if ( ( pulseLen < ( longestLowPulse * lowMultiplier ) ) && ( stateCount < maxState ) ) 
      {
        stateCount++;    
        return;
      };
    }

//********************************************************************************
// If you are here, then we have reached a pause (    should be a Low period 
// ending with a HIGH state, so interpret the array data to decipher 
// the "code" to serial (before trying again)      
//********************************************************************************
    data_output();
    trig            = false;       // initialise 
    stateCount      = 0;           // initialise 
    longestLowPulse = 0;
  };
}


//*********************************************************************************************
void data_output() {
//*********************************************************************************************

// If necessary, massage time length of "lastlow" to the "firstlow"  
// It is assumed that the "HIGH" state will never be long
    if ( pulseLen < firstLow ) { 
       T_array[stateCount] = firstLow;
    }

// Ignore incorrect wns pulses
   if ( firstLow < (longestLowPulse * 2) )
   {
     return;
   }

// Calculate pulses
    pulses = ( (stateCount + 1) / 2);

//********************************************************************************************
// Example Interpretion of message to Binary string which is then stored in B_array[]
// This example uses the length of the "High" state (Even indexes)
//    if long,  then this is a "0"
//    if short, then this is a "1"
// N.B.  B_array[] will always have half as many indexes as T_array[] !!
//  for(i=0; i<=stateCount; i=i+2){
//    if ( ( (T_array[i] * 10) + (5 * minlengthHI)  ) / (10 * minlengthHI) == 1 ) {
//      B_array[(i/2)] = 1;
//    } else {
//      B_array[(i/2)] = 0;
//    };
//  };
//  Serial.println(" ");

//********************************************************************************************
// Example check for a particular message ( unitlen = 660, pulses = 79, First 7 pulses are short Hi ) 
//  if (    (unitlen <  600)
//       || (unitlen >  700) 
//       || (pulses  != 79) 
//       || (B_array[0] != 1) || (B_array[1] != 1) || (B_array[2] != 1) || (B_array[3] != 1)  
//       || (B_array[4] != 1) || (B_array[5] != 1) || (B_array[6] != 1)) {
//    return;
//  };

//********************************************************************************************
// Example output of binary string
//  for(i=0; i<=pulses; i=i+1){
//    Serial.print(B_array[i]);
//  };
//  Serial.println(" ");    

//********************************************************************************************
// Output deciphered data for TX sketch
    Serial.print("int codez[] = {35,");
    Serial.print( pulses );
    Serial.print(",");
    Serial.print(shortestHiPulse);
    for(i=0; i<=stateCount; i=i+1){
      Serial.print(",");
//    Serial.print( (T_array[i] / shortestHiPulse) );          // Alternative round down
      Serial.print( ( (T_array[i] * 10) + (5 * shortestHiPulse)  ) / (10 * shortestHiPulse) );
    };
    Serial.println("};");

}
